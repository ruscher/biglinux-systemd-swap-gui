#!/usr/bin/env python3
"""
Services module for BigLinux Swap Manager.

Handles all system interactions: config parsing, memory monitoring,
swap management, storage detection, and service control.
"""

from __future__ import annotations

import contextlib
import logging
import re
import subprocess
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import TYPE_CHECKING

import gi

gi.require_version("GLib", "2.0")
from gi.repository import GLib

if TYPE_CHECKING:
    from biglinux_swap.config import SwapConfig

from biglinux_swap.config import (
    CHART_UPDATE_INTERVAL_MS,
    CONFIG_FILE,
    DEFAULT_CONFIG,
    MEMINFO_PATH,
    STORAGE_SWAP_PRIORITY,
    Compressor,
    MglruTtl,
    StorageType,
    SwapConfig,
    SwapFileInfo,
    SwapMode,
    SwapPartitionInfo,
    VirtualizationType,
)

logger = logging.getLogger(__name__)

# MGLRU sysfs path
MGLRU_ENABLED_PATH = Path("/sys/kernel/mm/lru_gen/enabled")


def is_mglru_supported() -> bool:
    """Check if MGLRU is supported by the current kernel."""
    return MGLRU_ENABLED_PATH.exists()


# =============================================================================
# Configuration Service
# =============================================================================


class ConfigService:
    """Service for managing systemd-swap configuration files."""

    def __init__(self) -> None:
        self._config: SwapConfig | None = None

    def load(self) -> SwapConfig:
        """Load configuration from system files."""
        config = SwapConfig()

        if DEFAULT_CONFIG.exists():
            default_values = self._parse_config_file(DEFAULT_CONFIG)
            config = self._apply_values(config, default_values)

        if CONFIG_FILE.exists():
            user_values = self._parse_config_file(CONFIG_FILE)
            config = self._apply_values(config, user_values)

        self._config = config
        logger.info("Configuration loaded")
        return config

    def get(self) -> SwapConfig:
        """Get current config, loading if necessary."""
        if self._config is None:
            return self.load()
        return self._config

    def generate_config_content(self, config: SwapConfig) -> str:
        """Generate configuration file content from SwapConfig."""
        lines = [
            "# Configuration for systemd-swap",
            "# Generated by BigLinux Swap Manager",
            "",
            f"swap_mode={config.mode.value}",
            "",
            "# Zswap",
            f"zswap_compressor={config.zswap.compressor.value}",
            f"zswap_max_pool_percent={config.zswap.max_pool_percent}",
            f"zswap_shrinker_enabled={1 if config.zswap.shrinker_enabled else 0}",
            f"zswap_accept_threshold={config.zswap.accept_threshold}",
            "",
            "# Zram",
            f"zram_size={config.zram.size_percent}%",
            f"zram_alg={config.zram.alg.value}",
            f"zram_mem_limit={config.zram.mem_limit_percent}%",
            f"zram_prio={config.zram.priority}",
            f"zram_writeback={1 if config.zram.writeback_enabled else 0}",
            "",
            "# SwapFile",
            f"swapfile_enabled={1 if config.swapfile.enabled else 0}",
            f"swapfile_path={config.swapfile.path}",
            f"swapfile_chunk_size={config.swapfile.chunk_size}",
            f"swapfile_max_count={config.swapfile.max_count}",
            "",
            "# MGLRU",
            f"mglru_min_ttl_ms={config.mglru_min_ttl.value}",
            "",
        ]
        return "\n".join(lines)

    def _parse_config_file(self, path: Path) -> dict[str, str]:
        """Parse a configuration file into key-value pairs."""
        values: dict[str, str] = {}
        try:
            with open(path, encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    if "=" in line:
                        key, _, value = line.partition("=")
                        key = key.strip()
                        value = value.strip()
                        if "#" in value:
                            value = value.split("#")[0].strip()
                        if value.startswith(('"', "'")) and value.endswith(('"', "'")):
                            value = value[1:-1]
                        values[key] = value
        except OSError as e:
            logger.error("Error reading config file %s: %s", path, e)
        return values

    def _apply_values(self, config: SwapConfig, values: dict[str, str]) -> SwapConfig:
        """Apply parsed values to a SwapConfig object."""
        if "swap_mode" in values:
            with contextlib.suppress(ValueError):
                config.mode = SwapMode(values["swap_mode"].lower())

        if "zswap_compressor" in values:
            with contextlib.suppress(ValueError):
                config.zswap.compressor = Compressor(values["zswap_compressor"])

        if "zswap_max_pool_percent" in values:
            config.zswap.max_pool_percent = self._parse_int(
                values["zswap_max_pool_percent"], config.zswap.max_pool_percent
            )

        if "zswap_zpool" in values:
            config.zswap.zpool = values["zswap_zpool"]

        if "zswap_shrinker_enabled" in values:
            config.zswap.shrinker_enabled = self._parse_bool(
                values["zswap_shrinker_enabled"]
            )

        if "zswap_accept_threshold" in values:
            config.zswap.accept_threshold = self._parse_int(
                values["zswap_accept_threshold"], config.zswap.accept_threshold
            )

        if "zram_size" in values:
            config.zram.size_percent = self._parse_percent(
                values["zram_size"], config.zram.size_percent
            )

        if "zram_alg" in values:
            with contextlib.suppress(ValueError):
                config.zram.alg = Compressor(values["zram_alg"])

        if "zram_mem_limit" in values:
            config.zram.mem_limit_percent = self._parse_percent(
                values["zram_mem_limit"], config.zram.mem_limit_percent
            )

        if "zram_prio" in values:
            config.zram.priority = self._parse_int(
                values["zram_prio"], config.zram.priority
            )

        if "zram_writeback" in values:
            config.zram.writeback_enabled = self._parse_bool(values["zram_writeback"])

        if "swapfile_enabled" in values:
            config.swapfile.enabled = self._parse_bool(values["swapfile_enabled"])

        if "swapfile_path" in values:
            config.swapfile.path = values["swapfile_path"]

        if "swapfile_chunk_size" in values:
            config.swapfile.chunk_size = values["swapfile_chunk_size"]

        if "swapfile_max_count" in values:
            config.swapfile.max_count = self._parse_int(
                values["swapfile_max_count"], config.swapfile.max_count
            )

        if "mglru_min_ttl_ms" in values:
            with contextlib.suppress(ValueError):
                config.mglru_min_ttl = MglruTtl(values["mglru_min_ttl_ms"])

        return config

    def _parse_int(self, value: str, default: int) -> int:
        try:
            return int(value.rstrip("%"))
        except ValueError:
            return default

    def _parse_percent(self, value: str, default: int) -> int:
        try:
            return int(value.rstrip("%"))
        except ValueError:
            return default

    def _parse_bool(self, value: str) -> bool:
        return value.lower() in ("yes", "y", "1", "true")


# =============================================================================
# Memory Statistics
# =============================================================================


@dataclass
class SwapDeviceStats:
    """Statistics for a single swap device."""

    path: str = ""
    device_type: str = ""
    size_bytes: int = 0
    used_bytes: int = 0
    priority: int = 0

    @property
    def usage_percent(self) -> float:
        if self.size_bytes == 0:
            return 0.0
        return (self.used_bytes / self.size_bytes) * 100.0

    @property
    def is_zram(self) -> bool:
        return "zram" in self.path


@dataclass
class MemoryStats:
    """Memory statistics from /proc/meminfo and /proc/swaps."""

    mem_total: int = 0
    mem_free: int = 0
    mem_available: int = 0
    mem_buffers: int = 0
    mem_cached: int = 0
    swap_total: int = 0
    swap_free: int = 0
    zswap_pool: int = 0
    zswap_stored: int = 0
    zram_used: int = 0
    swapfile_used: int = 0
    swap_devices: list[SwapDeviceStats] = field(default_factory=list)

    @property
    def mem_used(self) -> int:
        return self.mem_total - self.mem_available

    @property
    def swap_used(self) -> int:
        return self.swap_total - self.swap_free

    @property
    def swap_disk_used(self) -> int:
        if self.zswap_stored > 0:
            return max(0, self.swap_used - self.zswap_stored)
        elif self.zram_used > 0:
            return self.swapfile_used
        return self.swap_used

    @property
    def swap_in_ram(self) -> int:
        if self.zswap_stored > 0:
            return self.zswap_stored
        return self.zram_used

    @property
    def mem_used_percent(self) -> float:
        if self.mem_total == 0:
            return 0.0
        return (self.mem_used / self.mem_total) * 100.0

    @property
    def swap_used_percent(self) -> float:
        if self.swap_total == 0:
            return 0.0
        return (self.swap_used / self.swap_total) * 100.0

    def format_size(self, size_bytes: int) -> str:
        units = ["B", "KiB", "MiB", "GiB", "TiB"]
        unit_index = 0
        size = float(size_bytes)
        while size >= 1024 and unit_index < len(units) - 1:
            size /= 1024
            unit_index += 1
        if unit_index == 0:
            return f"{int(size)} {units[unit_index]}"
        return f"{size:.1f} {units[unit_index]}"

    @property
    def mem_total_formatted(self) -> str:
        return self.format_size(self.mem_total)

    @property
    def mem_used_formatted(self) -> str:
        return self.format_size(self.mem_used)

    @property
    def swap_total_formatted(self) -> str:
        return self.format_size(self.swap_total)

    @property
    def swap_used_formatted(self) -> str:
        return self.format_size(self.swap_used)

    @property
    def swap_ram_formatted(self) -> str:
        return self.format_size(self.swap_in_ram)

    @property
    def swap_disk_formatted(self) -> str:
        return self.format_size(self.swap_disk_used)

    @property
    def swap_ram_percent(self) -> float:
        if self.swap_total == 0:
            return 0.0
        return (self.swap_in_ram / self.swap_total) * 100.0

    @property
    def swap_disk_percent(self) -> float:
        if self.swap_total == 0:
            return 0.0
        return (self.swap_disk_used / self.swap_total) * 100.0


class MeminfoService:
    """Service for monitoring memory usage from /proc/meminfo."""

    def __init__(self) -> None:
        self._timer_id: int = 0
        self._callback: Callable[[MemoryStats], None] | None = None

    def get_stats(self) -> MemoryStats:
        """Read current memory statistics."""
        stats = MemoryStats()

        try:
            with open(MEMINFO_PATH, encoding="utf-8") as f:
                for line in f:
                    parts = line.split()
                    if len(parts) < 2:
                        continue
                    key = parts[0].rstrip(":")
                    value_bytes = int(parts[1]) * 1024

                    if key == "MemTotal":
                        stats.mem_total = value_bytes
                    elif key == "MemFree":
                        stats.mem_free = value_bytes
                    elif key == "MemAvailable":
                        stats.mem_available = value_bytes
                    elif key == "Buffers":
                        stats.mem_buffers = value_bytes
                    elif key == "Cached":
                        stats.mem_cached = value_bytes
                    elif key == "SwapTotal":
                        stats.swap_total = value_bytes
                    elif key == "SwapFree":
                        stats.swap_free = value_bytes
                    elif key == "Zswap":
                        stats.zswap_pool = value_bytes
                    elif key == "Zswapped":
                        stats.zswap_stored = value_bytes
        except (OSError, ValueError) as e:
            logger.error("Error reading meminfo: %s", e)

        self._read_swap_devices(stats)
        return stats

    def _read_swap_devices(self, stats: MemoryStats) -> None:
        """Read /proc/swaps to get detailed swap device info."""
        try:
            with open("/proc/swaps", encoding="utf-8") as f:
                next(f, None)
                zram_used = 0
                disk_used = 0
                devices: list[SwapDeviceStats] = []

                for line in f:
                    parts = line.split()
                    if len(parts) < 5:
                        continue
                    filename = parts[0]
                    device_type = parts[1]
                    size_bytes = int(parts[2]) * 1024
                    used_bytes = int(parts[3]) * 1024
                    priority = int(parts[4])

                    device = SwapDeviceStats(
                        path=filename,
                        device_type=device_type,
                        size_bytes=size_bytes,
                        used_bytes=used_bytes,
                        priority=priority,
                    )
                    devices.append(device)

                    if "zram" in filename:
                        zram_used += used_bytes
                    else:
                        disk_used += used_bytes

                stats.zram_used = zram_used
                stats.swapfile_used = disk_used
                stats.swap_devices = devices
        except (OSError, ValueError):
            pass

    def start_monitoring(
        self,
        callback: Callable[[MemoryStats], None],
        interval_ms: int = CHART_UPDATE_INTERVAL_MS,
    ) -> None:
        """Start periodic monitoring."""
        self.stop_monitoring()
        self._callback = callback

        def _update() -> bool:
            if self._callback is not None:
                stats = self.get_stats()
                self._callback(stats)
            return True

        self._timer_id = GLib.timeout_add(interval_ms, _update)
        _update()

    def stop_monitoring(self) -> None:
        """Stop periodic monitoring."""
        if self._timer_id:
            GLib.source_remove(self._timer_id)
            self._timer_id = 0
        self._callback = None


# =============================================================================
# Swap Service Status
# =============================================================================


class ServiceState(Enum):
    """systemd service states."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    FAILED = "failed"
    UNKNOWN = "unknown"


@dataclass
class ZswapStatus:
    """Zswap status information."""

    enabled: bool = False
    compressor: str = ""
    zpool: str = ""
    max_pool_percent: int = 0
    pool_size_bytes: int = 0
    stored_data_bytes: int = 0


@dataclass
class ZramStatus:
    """Zram status information."""

    enabled: bool = False
    total_size_bytes: int = 0
    used_bytes: int = 0


@dataclass
class SwapFileStatus:
    """SwapFile status information."""

    enabled: bool = False
    file_count: int = 0
    max_files: int = 32
    total_size_bytes: int = 0
    files: list[SwapFileInfo] = field(default_factory=list)

    @property
    def usage_percent(self) -> float:
        total_size = sum(f.size_bytes for f in self.files)
        total_used = sum(f.used_bytes for f in self.files)
        if total_size == 0:
            return 0.0
        return (total_used / total_size) * 100.0


@dataclass
class SwapPartitionStatus:
    """Swap partition status information."""

    partitions: list[SwapPartitionInfo] = field(default_factory=list)
    total_size_bytes: int = 0
    total_used_bytes: int = 0

    @property
    def usage_percent(self) -> float:
        if self.total_size_bytes == 0:
            return 0.0
        return (self.total_used_bytes / self.total_size_bytes) * 100.0


@dataclass
class SwapStatus:
    """Complete swap status information."""

    service_state: ServiceState = ServiceState.UNKNOWN
    mode: str = ""
    zswap: ZswapStatus = field(default_factory=ZswapStatus)
    zram: ZramStatus = field(default_factory=ZramStatus)
    swapfile: SwapFileStatus = field(default_factory=SwapFileStatus)
    partitions: SwapPartitionStatus = field(default_factory=SwapPartitionStatus)
    storage_type: StorageType = StorageType.UNKNOWN
    virtualization: VirtualizationType = VirtualizationType.NONE


class SwapService:
    """Service for interacting with systemd-swap."""

    def get_status(self) -> SwapStatus:
        """Get current swap status."""
        status = SwapStatus()
        status.service_state = self._get_service_state()

        try:
            result = subprocess.run(
                ["systemd-swap", "status"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                self._parse_status_output(status, result.stdout)
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError) as e:
            logger.warning("systemd-swap status: %s", e)

        # Read zswap statistics from /proc/meminfo
        self._read_zswap_stats(status)

        # Read swap files info from /proc/swaps
        status.swapfile.files = self.get_swapfiles_info()
        status.swapfile.file_count = len(status.swapfile.files)
        if status.swapfile.file_count > 0:
            status.swapfile.enabled = True
            status.swapfile.total_size_bytes = sum(f.size_bytes for f in status.swapfile.files)

        return status

    def _read_zswap_stats(self, status: SwapStatus) -> None:
        """Read zswap statistics from /proc/meminfo and sysfs."""
        try:
            # Check if zswap is enabled via sysfs
            zswap_enabled_path = Path("/sys/module/zswap/parameters/enabled")
            if zswap_enabled_path.exists():
                enabled_val = zswap_enabled_path.read_text().strip()
                status.zswap.enabled = enabled_val in ("Y", "1")

            # Read pool and stored bytes from /proc/meminfo
            with open(MEMINFO_PATH, encoding="utf-8") as f:
                for line in f:
                    parts = line.split()
                    if len(parts) < 2:
                        continue
                    key = parts[0].rstrip(":")
                    value_bytes = int(parts[1]) * 1024  # Convert kB to bytes

                    if key == "Zswap":
                        status.zswap.pool_size_bytes = value_bytes
                    elif key == "Zswapped":
                        status.zswap.stored_data_bytes = value_bytes

            # Read additional parameters from sysfs
            params_path = Path("/sys/module/zswap/parameters")
            if params_path.is_dir():
                compressor_file = params_path / "compressor"
                if compressor_file.exists():
                    status.zswap.compressor = compressor_file.read_text().strip()

                max_pool_file = params_path / "max_pool_percent"
                if max_pool_file.exists():
                    status.zswap.max_pool_percent = int(max_pool_file.read_text().strip())

        except (OSError, ValueError) as e:
            logger.debug("Error reading zswap stats: %s", e)

    def _get_service_state(self) -> ServiceState:
        """Get the state of the systemd-swap service."""
        try:
            result = subprocess.run(
                ["systemctl", "is-active", "systemd-swap"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            state = result.stdout.strip().lower()
            return {
                "active": ServiceState.ACTIVE,
                "inactive": ServiceState.INACTIVE,
                "failed": ServiceState.FAILED,
            }.get(state, ServiceState.UNKNOWN)
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError):
            return ServiceState.UNKNOWN

    def _parse_status_output(self, status: SwapStatus, output: str) -> None:
        """Parse the output of systemd-swap status."""
        current_section = None
        for line in output.strip().split("\n"):
            line = line.strip()
            if line.startswith("Zswap:"):
                current_section = "zswap"
                status.zswap.enabled = True
            elif line.startswith("Zram:"):
                current_section = "zram"
                status.zram.enabled = True
            elif line.startswith(("swapFC:", "swapFile:", "SwapFile:")):
                current_section = "swapfile"
                status.swapfile.enabled = True

            if ":" in line and current_section == "zswap":
                key, _, value = line.partition(":")
                key = key.strip().lower().replace(" ", "_")
                value = value.strip()
                if key == "compressor":
                    status.zswap.compressor = value
                elif key == "zpool":
                    status.zswap.zpool = value
                elif key == "max_pool_percent":
                    status.zswap.max_pool_percent = int(value.rstrip("%") or 0)

    def restart_service(self) -> tuple[bool, str]:
        """Restart the systemd-swap service."""
        try:
            result = subprocess.run(
                ["systemctl", "restart", "systemd-swap"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            if result.returncode == 0:
                return True, "Service restarted"
            return False, result.stderr.strip() or "Unknown error"
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError) as e:
            return False, str(e)

    def detect_virtualization(self) -> VirtualizationType:
        """Detect virtualization environment."""
        try:
            result = subprocess.run(
                ["systemd-detect-virt"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            virt_type = result.stdout.strip().lower()
            virt_map = {
                "none": VirtualizationType.NONE,
                "kvm": VirtualizationType.KVM,
                "qemu": VirtualizationType.KVM,
                "vmware": VirtualizationType.VMWARE,
                "oracle": VirtualizationType.VIRTUALBOX,
                "xen": VirtualizationType.XEN,
                "microsoft": VirtualizationType.HYPERV,
                "docker": VirtualizationType.DOCKER,
                "lxc": VirtualizationType.LXC,
                "wsl": VirtualizationType.WSL,
            }
            return virt_map.get(virt_type, VirtualizationType.OTHER)
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError):
            return VirtualizationType.NONE

    def detect_storage_type(self, path: str = "/") -> StorageType:
        """Detect storage type for a given path."""
        try:
            result = subprocess.run(
                ["df", "--output=source", path],
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode != 0:
                return StorageType.UNKNOWN

            lines = result.stdout.strip().split("\n")
            if len(lines) < 2:
                return StorageType.UNKNOWN

            device = lines[1].strip()
            base_device = self._get_base_device(device)

            if base_device.startswith("nvme"):
                return StorageType.NVME

            rotational_path = f"/sys/block/{base_device}/queue/rotational"
            try:
                with open(rotational_path, encoding="utf-8") as f:
                    rotational = f.read().strip()
                if rotational == "0":
                    return StorageType.SSD
                elif rotational == "1":
                    return StorageType.HDD
            except OSError:
                pass

            return StorageType.UNKNOWN
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError):
            return StorageType.UNKNOWN

    def _get_base_device(self, device: str) -> str:
        """Extract base device name from device path."""
        device = device.replace("/dev/", "")
        if device.startswith("nvme"):
            match = re.match(r"(nvme\d+n\d+)", device)
            if match:
                return match.group(1)
        if device.startswith("mmcblk"):
            match = re.match(r"(mmcblk\d+)", device)
            if match:
                return match.group(1)
        return re.sub(r"\d+$", "", device)

    def get_swap_priority(self, storage_type: StorageType) -> int:
        """Get recommended swap priority for storage type."""
        return STORAGE_SWAP_PRIORITY.get(storage_type, 0)

    def get_swapfiles_info(self) -> list[SwapFileInfo]:
        """Get detailed info for each active swap file."""
        files: list[SwapFileInfo] = []
        try:
            with open("/proc/swaps", encoding="utf-8") as f:
                next(f, None)
                for line in f:
                    parts = line.split()
                    if len(parts) < 5:
                        continue
                    filename = parts[0]
                    swap_type = parts[1]
                    size_kb = int(parts[2])
                    used_kb = int(parts[3])
                    priority = int(parts[4])

                    if swap_type == "file" or "loop" in filename:
                        files.append(
                            SwapFileInfo(
                                path=filename,
                                size_bytes=size_kb * 1024,
                                used_bytes=used_kb * 1024,
                                is_active=True,
                                priority=priority,
                            )
                        )
        except (OSError, ValueError) as e:
            logger.warning("Failed to read /proc/swaps: %s", e)
        return files

    def has_swapfiles_in_use(self) -> bool:
        """Check if there are swapfiles with data in use."""
        files = self.get_swapfiles_info()
        return any(f.used_bytes > 0 for f in files)

    def has_any_swap_in_use(self) -> bool:
        """
        Check if there is ANY swap (files, zram, partitions) with data in use.

        More conservative check - if any swap has data, it's safer to restart
        the system than to risk freezes by stopping active swap.
        """
        try:
            with open("/proc/swaps", encoding="utf-8") as f:
                next(f, None)  # Skip header
                for line in f:
                    parts = line.split()
                    if len(parts) >= 4:
                        used_kb = int(parts[3])
                        if used_kb > 0:
                            return True
            return False
        except (OSError, ValueError) as e:
            logger.warning("Failed to check swap usage: %s", e)
            # If we can't check, assume swap is in use for safety
            return True


# =============================================================================
# Public API
# =============================================================================

__all__ = [
    "ConfigService",
    "MeminfoService",
    "MemoryStats",
    "ServiceState",
    "SwapDeviceStats",
    "SwapFileStatus",
    "SwapPartitionStatus",
    "SwapService",
    "SwapStatus",
    "ZramStatus",
    "ZswapStatus",
]
